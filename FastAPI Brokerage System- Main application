from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime
from enum import Enum
import redis
import json
import uuid
import logging
from contextlib import asynccontextmanager

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Redis connection
try:
    redis_client = redis.Redis(host='redis', port=6379, db=0, decode_responses=True)
    redis_client.ping()
    logger.info("Connected to Redis successfully")
except Exception as e:
    logger.error(f"Failed to connect to Redis: {e}")
    redis_client = None

# Pydantic Models
class OrderSide(str, Enum):
    BUY = "BUY"
    SELL = "SELL"

class OrderType(str, Enum):
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP = "STOP"
    STOP_LIMIT = "STOP_LIMIT"

class OrderStatus(str, Enum):
    PENDING = "PENDING"
    FILLED = "FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"

class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: str = Field(..., regex=r'^[^@]+@[^@]+\.[^@]+$')
    full_name: str = Field(..., min_length=1, max_length=100)
    initial_balance: float = Field(default=10000.0, ge=0)

class UserResponse(BaseModel):
    id: str
    username: str
    email: str
    full_name: str
    balance: float
    created_at: datetime
    is_active: bool

class TradeOrder(BaseModel):
    user_id: str = Field(..., description="User ID placing the order")
    symbol: str = Field(..., min_length=1, max_length=10, description="Trading symbol (e.g., AAPL)")
    side: OrderSide = Field(..., description="BUY or SELL")
    order_type: OrderType = Field(..., description="Order type")
    quantity: int = Field(..., gt=0, description="Number of shares")
    price: Optional[float] = Field(None, gt=0, description="Price for limit orders")
    stop_price: Optional[float] = Field(None, gt=0, description="Stop price for stop orders")

class OrderResponse(BaseModel):
    order_id: str
    user_id: str
    symbol: str
    side: OrderSide
    order_type: OrderType
    quantity: int
    price: Optional[float]
    stop_price: Optional[float]
    status: OrderStatus
    created_at: datetime
    message: str

# In-memory storage (replace with database in production)
users_db: Dict[str, dict] = {}
orders_db: Dict[str, dict] = {}

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    logger.info("Starting up brokerage API...")
    # Create some dummy users for testing
    dummy_users = [
        {
            "id": "user_1",
            "username": "john_trader",
            "email": "john@example.com",
            "full_name": "John Trader",
            "balance": 50000.0,
            "created_at": datetime.now(),
            "is_active": True
        },
        {
            "id": "user_2", 
            "username": "jane_investor",
            "email": "jane@example.com",
            "full_name": "Jane Investor",
            "balance": 75000.0,
            "created_at": datetime.now(),
            "is_active": True
        }
    ]
    
    for user in dummy_users:
        users_db[user["id"]] = user
    
    logger.info(f"Created {len(dummy_users)} dummy users for testing")
    yield
    # Shutdown
    logger.info("Shutting down brokerage API...")

# Initialize FastAPI app
app = FastAPI(
    title="Brokerage Trading API",
    description="A FastAPI-based brokerage system for trading through Interactive Brokers",
    version="1.0.0",
    lifespan=lifespan
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Health check endpoint
@app.get("/health", tags=["Health"])
async def health_check():
    """Health check endpoint"""
    redis_status = "connected" if redis_client else "disconnected"
    return {
        "status": "healthy",
        "timestamp": datetime.now(),
        "services": {
            "redis": redis_status,
            "api": "running"
        }
    }

# User Service Endpoints
@app.post("/user/", response_model=UserResponse, status_code=status.HTTP_201_CREATED, tags=["Users"])
async def create_user(user: UserCreate):
    """Create a new user account"""
    # Check if username already exists
    for existing_user in users_db.values():
        if existing_user["username"] == user.username:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already exists"
            )
        if existing_user["email"] == user.email:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already exists"
            )
    
    # Create new user
    user_id = f"user_{uuid.uuid4().hex[:8]}"
    new_user = {
        "id": user_id,
        "username": user.username,
        "email": user.email,
        "full_name": user.full_name,
        "balance": user.initial_balance,
        "created_at": datetime.now(),
        "is_active": True
    }
    
    users_db[user_id] = new_user
    logger.info(f"Created new user: {user_id}")
    
    return UserResponse(**new_user)

@app.get("/user/{user_id}", response_model=UserResponse, tags=["Users"])
async def get_user(user_id: str):
    """Get user information by ID"""
    if user_id not in users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    user = users_db[user_id]
    return UserResponse(**user)

@app.get("/user/", response_model=List[UserResponse], tags=["Users"])
async def list_users(skip: int = 0, limit: int = 10):
    """List all users with pagination"""
    users_list = list(users_db.values())[skip:skip + limit]
    return [UserResponse(**user) for user in users_list]

@app.put("/user/{user_id}/balance", tags=["Users"])
async def update_user_balance(user_id: str, new_balance: float = Field(..., ge=0)):
    """Update user balance (for testing purposes)"""
    if user_id not in users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    users_db[user_id]["balance"] = new_balance
    logger.info(f"Updated balance for user {user_id}: ${new_balance}")
    
    return {"message": f"Balance updated to ${new_balance}", "user_id": user_id}

# Trading Service Endpoints
@app.post("/order", response_model=OrderResponse, status_code=status.HTTP_201_CREATED, tags=["Trading"])
async def create_order(order: TradeOrder):
    """Submit a new trading order"""
    # Validate user exists
    if order.user_id not in users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Validate order data
    if order.order_type in [OrderType.LIMIT, OrderType.STOP_LIMIT] and order.price is None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Price is required for limit orders"
        )
    
    if order.order_type in [OrderType.STOP, OrderType.STOP_LIMIT] and order.stop_price is None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Stop price is required for stop orders"
        )
    
    # Create order
    order_id = f"order_{uuid.uuid4().hex[:8]}"
    order_data = {
        "order_id": order_id,
        "user_id": order.user_id,
        "symbol": order.symbol.upper(),
        "side": order.side,
        "order_type": order.order_type,
        "quantity": order.quantity,
        "price": order.price,
        "stop_price": order.stop_price,
        "status": OrderStatus.PENDING,
        "created_at": datetime.now(),
        "message": "Order received and queued for processing"
    }
    
    # Store order
    orders_db[order_id] = order_data
    
    # Push to Redis queue for processing
    if redis_client:
        try:
            queue_data = {
                **order_data,
                "created_at": order_data["created_at"].isoformat()
            }
            redis_client.lpush("trading_queue", json.dumps(queue_data))
            logger.info(f"Order {order_id} added to Redis queue")
        except Exception as e:
            logger.error(f"Failed to add order to Redis queue: {e}")
    
    return OrderResponse(**order_data)

@app.get("/order/{order_id}", response_model=OrderResponse, tags=["Trading"])
async def get_order(order_id: str):
    """Get order information by ID"""
    if order_id not in orders_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Order not found"
        )
    
    order = orders_db[order_id]
    return OrderResponse(**order)

@app.get("/orders/user/{user_id}", response_model=List[OrderResponse], tags=["Trading"])
async def get_user_orders(user_id: str, skip: int = 0, limit: int = 10):
    """Get all orders for a specific user"""
    if user_id not in users_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    user_orders = [
        order for order in orders_db.values() 
        if order["user_id"] == user_id
    ][skip:skip + limit]
    
    return [OrderResponse(**order) for order in user_orders]

@app.delete("/order/{order_id}", tags=["Trading"])
async def cancel_order(order_id: str):
    """Cancel a pending order"""
    if order_id not in orders_db:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Order not found"
        )
    
    order = orders_db[order_id]
    if order["status"] != OrderStatus.PENDING:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Can only cancel pending orders"
        )
    
    order["status"] = OrderStatus.CANCELLED
    order["message"] = "Order cancelled by user"
    
    logger.info(f"Order {order_id} cancelled")
    
    return {"message": "Order cancelled successfully", "order_id": order_id}

# Queue monitoring endpoints
@app.get("/queue/status", tags=["Queue"])
async def get_queue_status():
    """Get Redis queue status"""
    if not redis_client:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Redis not available"
        )
    
    try:
        queue_length = redis_client.llen("trading_queue")
        return {
            "queue_length": queue_length,
            "timestamp": datetime.now()
        }
    except Exception as e:
        logger.error(f"Failed to get queue status: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to get queue status"
        )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
