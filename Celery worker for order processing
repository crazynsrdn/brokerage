from celery import Celery
import redis
import json
import time
import logging
from datetime import datetime
from typing import Dict, Any
import random

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize Celery
celery_app = Celery('brokerage_worker')
celery_app.conf.update(
    broker='redis://redis:6379/0',
    result_backend='redis://redis:6379/0',
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='UTC',
    enable_utc=True,
)

# Redis client for direct queue processing
redis_client = redis.Redis(host='redis', port=6379, db=0, decode_responses=True)

@celery_app.task
def process_trade_order(order_data: Dict[str, Any]):
    """
    Process a trade order (dummy implementation)
    In production, this would connect to Interactive Brokers API
    """
    try:
        order_id = order_data.get('order_id')
        symbol = order_data.get('symbol')
        side = order_data.get('side')
        quantity = order_data.get('quantity')
        order_type = order_data.get('order_type')
        
        logger.info(f"Processing order {order_id}: {side} {quantity} {symbol} ({order_type})")
        
        # Simulate processing time
        processing_time = random.uniform(1, 3)
        time.sleep(processing_time)
        
        # Simulate order execution (90% success rate)
        success = random.random() > 0.1
        
        if success:
            # Simulate fill price (market orders get random price near current market)
            if order_type == 'MARKET':
                fill_price = round(random.uniform(100, 500), 2)
            else:
                fill_price = order_data.get('price', random.uniform(100, 500))
            
            result = {
                'order_id': order_id,
                'status': 'FILLED',
                'fill_price': fill_price,
                'fill_quantity': quantity,
                'fill_time': datetime.now().isoformat(),
                'message': f'Order filled at ${fill_price}'
            }
            
            logger.info(f"Order {order_id} FILLED at ${fill_price}")
        else:
            result = {
                'order_id': order_id,
                'status': 'REJECTED',
                'message': 'Order rejected by broker (simulated)',
                'rejection_time': datetime.now().isoformat()
            }
            
            logger.warning(f"Order {order_id} REJECTED")
        
        # Store result in Redis for API to retrieve
        redis_client.hset(f"order_result:{order_id}", mapping=result)
        redis_client.expire(f"order_result:{order_id}", 3600)  # Expire in 1 hour
        
        return result
        
    except Exception as e:
        logger.error(f"Error processing order: {e}")
        return {
            'order_id': order_data.get('order_id', 'unknown'),
            'status': 'ERROR',
            'message': f'Processing error: {str(e)}'
        }

@celery_app.task
def health_check():
    """Health check task for Celery worker"""
    return {
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'worker': 'brokerage_worker'
    }

def redis_queue_worker():
    """
    Alternative simple Redis queue worker
    Use this if you prefer not to use Celery
    """
    logger.info("Starting Redis queue worker...")
    
    while True:
        try:
            # Blocking pop from Redis queue
            queue_item = redis_client.brpop("trading_queue", timeout=5)
            
            if queue_item:
                queue_name, order_json = queue_item
                order_data = json.loads(order_json)
                
                logger.info(f"Processing order from Redis queue: {order_data.get('order_id')}")
                
                # Process the order using the same logic as Celery task
                result = process_trade_order.apply(args=[order_data]).get()
                
                logger.info(f"Completed processing: {result}")
            
        except KeyboardInterrupt:
            logger.info("Worker stopped by user")
            break
        except Exception as e:
            logger.error(f"Error in queue worker: {e}")
            time.sleep(1)

if __name__ == '__main__':
    # Run the simple Redis worker instead of Celery
    redis_queue_worker()
